// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.6 (swiftlang-5.6.0.323.62 clang-1316.0.20.8)
// swift-module-flags: -target arm64-apple-ios9.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name DequeModule
import Swift
import _Concurrency
extension Swift.Array {
  @inlinable internal static func _isWCSIABroken() -> Swift.Bool {
    guard _isBridgedVerbatimToObjectiveC(Element.self) else {
      // SR-14663 only triggers on array values that are verbatim bridged
      // from Objective-C, so it cannot ever trigger for element types
      // that aren't verbatim bridged.
      return false
    }

    // SR-14663 was introduced in Swift 5.1. Check if we have a broken stdlib.

    // The bug is caused by a bogus precondition inside a non-inlinable stdlib
    // method, so to determine if we're affected, we need to check the currently
    // running OS version.
    guard #available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *) else {
      // The OS is too old to be affected by this bug.
      return false
    }
    // FIXME: When a stdlib is released that contains a fix, add a check for it.
    return true

  }
}
extension Swift.Sequence {
  @inlinable internal func _withContiguousStorageIfAvailable_SR14663<R>(_ body: (Swift.UnsafeBufferPointer<Self.Element>) throws -> R) rethrows -> R? {
    if Self.self == Array<Element>.self && Array<Element>._isWCSIABroken() {
      return nil
    }

    return try self.withContiguousStorageIfAvailable(body)
  }
}
extension DequeModule.Deque : Swift.Encodable where Element : Swift.Encodable {
  @inlinable public func encode(to encoder: Swift.Encoder) throws {
    var container = encoder.unkeyedContainer()
    for element in self {
      try container.encode(element)
    }
  }
}
extension DequeModule.Deque : Swift.Decodable where Element : Swift.Decodable {
  @inlinable public init(from decoder: Swift.Decoder) throws {
    self.init()

    var container = try decoder.unkeyedContainer()
    if let count = container.count {
      self.reserveCapacity(count)
    }
    while !container.isAtEnd {
      let element = try container.decode(Element.self)
      self.append(element)
    }
  }
}
extension DequeModule.Deque : Swift.Sequence {
  @frozen public struct Iterator : Swift.IteratorProtocol {
    @usableFromInline
    internal var _storage: DequeModule.Deque<Element>._Storage
    @usableFromInline
    internal var _nextSlot: DequeModule.Deque<Element>._Slot
    @usableFromInline
    internal var _endSlot: DequeModule.Deque<Element>._Slot
    @inlinable internal init(_storage: DequeModule.Deque<Element>._Storage, start: DequeModule.Deque<Element>._Slot, end: DequeModule.Deque<Element>._Slot) {
      self._storage = _storage
      self._nextSlot = start
      self._endSlot = end
    }
    @inlinable internal init(_base: DequeModule.Deque<Element>) {
      self = _base._storage.read { handle in
        let start = handle.startSlot
        let end = Swift.min(start.advanced(by: handle.count), handle.limSlot)
        return Self(_storage: _base._storage, start: start, end: end)
      }
    }
    @inlinable internal init(_base: DequeModule.Deque<Element>, from index: Swift.Int) {
      self = _base._storage.read { handle in
        assert(index >= 0 && index <= handle.count)
        let start = handle.slot(forOffset: index)
        if index == handle.count {
          return Self(_storage: _base._storage, start: start, end: start)
        }
        var end = handle.endSlot
        if start >= end { end = handle.limSlot }
        return Self(_storage: _base._storage, start: start, end: end)
      }
    }
    @inlinable @inline(never) internal mutating func _swapSegment() -> Swift.Bool {
      assert(_nextSlot == _endSlot)
      return _storage.read { handle in
        let end = handle.endSlot
        if end == .zero || end == _nextSlot {
          return false
        }
        _endSlot = end
        _nextSlot = .zero
        return true
      }
    }
    @inlinable public mutating func next() -> Element? {
      if _nextSlot == _endSlot {
        guard _swapSegment() else { return nil }
      }
      assert(_nextSlot < _endSlot)
      let slot = _nextSlot
      _nextSlot = _nextSlot.advanced(by: 1)
      return _storage.read { handle in
        return handle.ptr(at: slot).pointee
      }
    }
  }
  @inlinable public func makeIterator() -> DequeModule.Deque<Element>.Iterator {
    Iterator(_base: self)
  }
  @inlinable public __consuming func _copyToContiguousArray() -> Swift.ContiguousArray<Element> {
    ContiguousArray(unsafeUninitializedCapacity: _storage.count) { target, count in
      _storage.read { source in
        let segments = source.segments()
        let c = segments.first.count
        target[..<c]._rebased()._initialize(from: segments.first)
        count += segments.first.count
        if let second = segments.second {
          target[c ..< c + second.count]._rebased()._initialize(from: second)
          count += second.count
        }
        assert(count == source.count)
      }
    }
  }
  @inlinable public __consuming func _copyContents(initializing target: Swift.UnsafeMutableBufferPointer<Element>) -> (DequeModule.Deque<Element>.Iterator, Swift.UnsafeMutableBufferPointer<Element>.Index) {
    _storage.read { source in
      let segments = source.segments()
      let c1 = Swift.min(segments.first.count, target.count)
      target[..<c1]._rebased()._initialize(from: segments.first.prefix(c1)._rebased())
      guard target.count > c1, let second = segments.second else {
        return (Iterator(_base: self, from: c1), c1)
      }
      let c2 = Swift.min(second.count, target.count - c1)
      target[c1 ..< c1 + c2]._rebased()._initialize(from: second.prefix(c2)._rebased())
      return (Iterator(_base: self, from: c1 + c2), c1 + c2)
    }
  }
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try _storage.read { handle in
      let endSlot = handle.startSlot.advanced(by: handle.count)
      guard endSlot.position <= handle.capacity else { return nil }
      return try body(handle.buffer(for: handle.startSlot ..< endSlot))
    }
  }
}
extension DequeModule.Deque : Swift.RandomAccessCollection {
  public typealias Index = Swift.Int
  public typealias SubSequence = Swift.Slice<DequeModule.Deque<Element>>
  public typealias Indices = Swift.Range<Swift.Int>
  @inlinable @inline(__always) public var count: Swift.Int {
    get { _storage.count }
  }
  @inlinable @inline(__always) public var startIndex: Swift.Int {
    get { 0 }
  }
  @inlinable @inline(__always) public var endIndex: Swift.Int {
    get { count }
  }
  @inlinable @inline(__always) public var indices: Swift.Range<Swift.Int> {
    get { 0 ..< count }
  }
  @inlinable @inline(__always) public func index(after i: Swift.Int) -> Swift.Int {
    // Note: Like `Array`, index manipulation methods on deques don't trap on
    // invalid indices. (Indices are still validated on element access.)
    return i + 1
  }
  @inlinable @inline(__always) public func formIndex(after i: inout Swift.Int) {
    // Note: Like `Array`, index manipulation methods on deques
    // don't trap on invalid indices.
    // (Indices are still validated on element access.)
    i += 1
  }
  @inlinable @inline(__always) public func index(before i: Swift.Int) -> Swift.Int {
    // Note: Like `Array`, index manipulation methods on deques don't trap on
    // invalid indices. (Indices are still validated on element access.)
    return i - 1
  }
  @inlinable @inline(__always) public func formIndex(before i: inout Swift.Int) {
    // Note: Like `Array`, index manipulation methods on deques don't trap on
    // invalid indices. (Indices are still validated on element access.)
    i -= 1
  }
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int) -> Swift.Int {
    // Note: Like `Array`, index manipulation methods on deques don't trap on
    // invalid indices. (Indices are still validated on element access.)
    return i + distance
  }
  @inlinable public func index(_ i: Swift.Int, offsetBy distance: Swift.Int, limitedBy limit: Swift.Int) -> Swift.Int? {
    // Note: Like `Array`, index manipulation methods on deques
    // don't trap on invalid indices.
    // (Indices are still validated on element access.)
    let l = limit - i
    if distance > 0 ? l >= 0 && l < distance : l <= 0 && distance < l {
      return nil
    }
    return i + distance
  }
  @inlinable @inline(__always) public func distance(from start: Swift.Int, to end: Swift.Int) -> Swift.Int {
    // Note: Like `Array`, index manipulation method on deques
    // don't trap on invalid indices.
    // (Indices are still validated on element access.)
    return end - start
  }
  @inlinable public subscript(index: Swift.Int) -> Element {
    get {
      precondition(index >= 0 && index < count, "Index out of bounds")
      return _storage.read { $0.ptr(at: $0.slot(forOffset: index)).pointee }
    }
    set {
      precondition(index >= 0 && index < count, "Index out of bounds")
      _storage.ensureUnique()
      _storage.update { handle in
        let slot = handle.slot(forOffset: index)
        handle.ptr(at: slot).pointee = newValue
      }
    }
    _modify {
      precondition(index >= 0 && index < count, "Index out of bounds")
      _storage.ensureUnique()
      // We technically aren't supposed to escape storage pointers out of a
      // managed buffer, so we escape a `(slot, value)` pair instead, leaving
      // the corresponding slot temporarily uninitialized.
      var (slot, value) = _storage.update { handle -> (_Slot, Element) in
        let slot = handle.slot(forOffset: index)
        return (slot, handle.ptr(at: slot).move())
      }
      defer {
        _storage.update { handle in
          handle.ptr(at: slot).initialize(to: value)
        }
      }
      yield &value
    }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Int>) -> Swift.Slice<DequeModule.Deque<Element>> {
    get {
      precondition(bounds.lowerBound >= 0 && bounds.upperBound <= count,
                   "Invalid bounds")
      return Slice(base: self, bounds: bounds)
    }
    set(source) {
      precondition(bounds.lowerBound >= 0 && bounds.upperBound <= count,
                   "Invalid bounds")
      self.replaceSubrange(bounds, with: source)
    }
  }
}
extension DequeModule.Deque : Swift.MutableCollection {
  @inlinable public mutating func swapAt(_ i: Swift.Int, _ j: Swift.Int) {
    precondition(i >= 0 && i < count, "Index out of bounds")
    precondition(j >= 0 && j < count, "Index out of bounds")
    _storage.ensureUnique()
    _storage.update { handle in
      let slot1 = handle.slot(forOffset: i)
      let slot2 = handle.slot(forOffset: j)
      handle.mutableBuffer.swapAt(slot1.position, slot2.position)
    }
  }
  @inlinable public mutating func withContiguousMutableStorageIfAvailable<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    _storage.ensureUnique()
    return try _storage.update { handle in
      let endSlot = handle.startSlot.advanced(by: handle.count)
      guard endSlot.position <= handle.capacity else {
        // FIXME: Rotate storage such that it becomes contiguous.
        return nil
      }
      let original = handle.mutableBuffer(for: handle.startSlot ..< endSlot)
      var extract = original
      defer {
        precondition(extract.baseAddress == original.baseAddress && extract.count == original.count,
                     "Closure must not replace the provided buffer")
      }
      return try body(&extract)
    }
  }
  @inlinable public mutating func _withUnsafeMutableBufferPointerIfSupported<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try withContiguousMutableStorageIfAvailable(body)
  }
}
extension DequeModule.Deque : Swift.RangeReplaceableCollection {
  @inlinable public init() {
    _storage = _Storage()
  }
  @inlinable public mutating func reserveCapacity(_ minimumCapacity: Swift.Int) {
    _storage.ensureUnique(minimumCapacity: minimumCapacity, linearGrowth: true)
  }
  @inlinable public mutating func replaceSubrange<C>(_ subrange: Swift.Range<Swift.Int>, with newElements: __owned C) where Element == C.Element, C : Swift.Collection {
    precondition(subrange.lowerBound >= 0 && subrange.upperBound <= count, "Index range out of bounds")
    let removalCount = subrange.count
    let insertionCount = newElements.count
    let deltaCount = insertionCount - removalCount
    _storage.ensureUnique(minimumCapacity: count + deltaCount)

    let replacementCount = Swift.min(removalCount, insertionCount)
    let targetCut = subrange.lowerBound + replacementCount
    let sourceCut = newElements.index(newElements.startIndex, offsetBy: replacementCount)

    _storage.update { target in
      target.uncheckedReplaceInPlace(
        inOffsets: subrange.lowerBound ..< targetCut,
        with: newElements[..<sourceCut])
      if deltaCount < 0 {
        let r = targetCut ..< subrange.upperBound
        assert(replacementCount + r.count == removalCount)
        target.uncheckedRemove(offsets: r)
      } else if deltaCount > 0 {
        target.uncheckedInsert(
          contentsOf: newElements[sourceCut...],
          count: deltaCount,
          atOffset: targetCut)
      }
    }
  }
  @inlinable public init(repeating repeatedValue: Element, count: Swift.Int) {
    precondition(count >= 0)
    self.init(minimumCapacity: count)
    _storage.update { handle in
      assert(handle.startSlot == .zero)
      if count > 0 {
        handle.ptr(at: .zero).initialize(repeating: repeatedValue, count: count)
      }
      handle.count = count
    }
  }
  @inlinable public init<S>(_ elements: S) where Element == S.Element, S : Swift.Sequence {
    self.init()
    self.append(contentsOf: elements)
  }
  @inlinable public init<C>(_ elements: C) where Element == C.Element, C : Swift.Collection {
    let c = elements.count
    guard c > 0 else { _storage = _Storage(); return }
    self._storage = _Storage(minimumCapacity: c)
    _storage.update { handle in
      assert(handle.startSlot == .zero)
      let target = handle.mutableBuffer(for: .zero ..< _Slot(at: c))
      let done: Void? = elements._withContiguousStorageIfAvailable_SR14663 { source in
        target._initialize(from: source)
      }
      if done == nil {
        target._initialize(from: elements)
      }
      handle.count = c
    }
  }
  @inlinable public mutating func append(_ newElement: Element) {
    _storage.ensureUnique(minimumCapacity: count + 1)
    _storage.update {
      $0.uncheckedAppend(newElement)
    }
  }
  @inlinable public mutating func append<S>(contentsOf newElements: S) where Element == S.Element, S : Swift.Sequence {
    let done: Void? = newElements._withContiguousStorageIfAvailable_SR14663 { source in
      _storage.ensureUnique(minimumCapacity: count + source.count)
      _storage.update { $0.uncheckedAppend(contentsOf: source) }
    }
    if done != nil {
      return
    }

    let underestimatedCount = newElements.underestimatedCount
    _storage.ensureUnique(minimumCapacity: count + underestimatedCount)
    var it: S.Iterator = _storage.update { target in
      let gaps = target.availableSegments()
      let (it, copied) = gaps.initialize(fromSequencePrefix: newElements)
      target.count += copied
      return it
    }
    while let next = it.next() {
      _storage.ensureUnique(minimumCapacity: count + 1)
      _storage.update { target in
        target.uncheckedAppend(next)
        let gaps = target.availableSegments()
        target.count += gaps.initialize(fromPrefixOf: &it)
      }
    }
  }
  @inlinable public mutating func append<C>(contentsOf newElements: C) where Element == C.Element, C : Swift.Collection {
    let done: Void? = newElements._withContiguousStorageIfAvailable_SR14663 { source in
      _storage.ensureUnique(minimumCapacity: count + source.count)
      _storage.update { $0.uncheckedAppend(contentsOf: source) }
    }
    guard done == nil else { return }

    let c = newElements.count
    guard c > 0 else { return }
    _storage.ensureUnique(minimumCapacity: count + c)
    _storage.update { target in
      let gaps = target.availableSegments().prefix(c)
      gaps.initialize(from: newElements)
      target.count += c
    }
  }
  @inlinable public mutating func insert(_ newElement: Element, at index: Swift.Int) {
    precondition(index >= 0 && index <= count,
                 "Can't insert element at invalid index")
    _storage.ensureUnique(minimumCapacity: count + 1)
    _storage.update { target in
      if index == 0 {
        target.uncheckedPrepend(newElement)
        return
      }
      if index == count {
        target.uncheckedAppend(newElement)
        return
      }
      let gap = target.openGap(ofSize: 1, atOffset: index)
      assert(gap.first.count == 1)
      gap.first.baseAddress!.initialize(to: newElement)
    }
  }
  @inlinable public mutating func insert<C>(contentsOf newElements: __owned C, at index: Swift.Int) where Element == C.Element, C : Swift.Collection {
    precondition(index >= 0 && index <= count,
                 "Can't insert elements at an invalid index")
    let newCount = newElements.count
    _storage.ensureUnique(minimumCapacity: count + newCount)
    _storage.update { target in
      target.uncheckedInsert(contentsOf: newElements, count: newCount, atOffset: index)
    }
  }
  @discardableResult
  @inlinable public mutating func remove(at index: Swift.Int) -> Element {
    precondition(index >= 0 && index < self.count, "Index out of bounds")
    // FIXME: Implement storage shrinking
    _storage.ensureUnique()
    return _storage.update { target in
      // FIXME: Add direct implementation & see if it makes a difference
      let result = self[index]
      target.uncheckedRemove(offsets: index ..< index + 1)
      return result
    }
  }
  @inlinable public mutating func removeSubrange(_ bounds: Swift.Range<Swift.Int>) {
    precondition(bounds.lowerBound >= 0 && bounds.upperBound <= self.count,
                 "Index range out of bounds")
    _storage.ensureUnique()
    _storage.update { $0.uncheckedRemove(offsets: bounds) }
  }
  @inlinable public mutating func _customRemoveLast() -> Element? {
    precondition(!isEmpty, "Cannot remove last element of an empty Deque")
    _storage.ensureUnique()
    return _storage.update { $0.uncheckedRemoveLast() }
  }
  @inlinable public mutating func _customRemoveLast(_ n: Swift.Int) -> Swift.Bool {
    precondition(n >= 0, "Can't remove a negative number of elements")
    precondition(n <= count, "Can't remove more elements than there are in the Collection")
    _storage.ensureUnique()
    _storage.update { $0.uncheckedRemoveLast(n) }
    return true
  }
  @discardableResult
  @inlinable public mutating func removeFirst() -> Element {
    precondition(!isEmpty, "Cannot remove first element of an empty Deque")
    _storage.ensureUnique()
    return _storage.update { $0.uncheckedRemoveFirst() }
  }
  @inlinable public mutating func removeFirst(_ n: Swift.Int) {
    precondition(n >= 0, "Can't remove a negative number of elements")
    precondition(n <= count, "Can't remove more elements than there are in the Collection")
    _storage.ensureUnique()
    return _storage.update { $0.uncheckedRemoveFirst(n) }
  }
  @inlinable public mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool = false) {
    if keepCapacity {
      _storage.ensureUnique()
      _storage.update { $0.uncheckedRemoveAll() }
    } else {
      self = Deque()
    }
  }
}
extension DequeModule.Deque : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension DequeModule.Deque : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension DequeModule.Deque : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension DequeModule.Deque : Swift.Equatable where Element : Swift.Equatable {
  @inlinable public static func == (left: DequeModule.Deque<Element>, right: DequeModule.Deque<Element>) -> Swift.Bool {
    return left.elementsEqual(right)
  }
}
extension DequeModule.Deque : Swift.ExpressibleByArrayLiteral {
  @inlinable @inline(__always) public init(arrayLiteral elements: Element...) {
    self.init(elements)
  }
  public typealias ArrayLiteralElement = Element
}
extension DequeModule.Deque {
  @inlinable public init(unsafeUninitializedCapacity capacity: Swift.Int, initializingWith initializer: (inout Swift.UnsafeMutableBufferPointer<Element>, inout Swift.Int) throws -> Swift.Void) rethrows {
    self._storage = .init(minimumCapacity: capacity)
    try _storage.update { handle in
      handle.startSlot = .zero
      var count = 0
      var buffer = handle.mutableBuffer(for: .zero ..< _Slot(at: capacity))
      defer {
        precondition(count <= capacity,
          "Initialized count set to greater than specified capacity")
        let b = handle.mutableBuffer(for: .zero ..< _Slot(at: capacity))
        precondition(buffer.baseAddress == b.baseAddress && buffer.count == b.count,
          "Initializer relocated Deque storage")
        handle.count = count
      }
      try initializer(&buffer, &count)
    }
  }
}
extension DequeModule.Deque {
  @inlinable public mutating func popFirst() -> Element? {
    // FIXME: Add this to the stdlib on BidirectionalCollection
    // where Self == Self.SubSequence
    guard count > 0 else { return nil }
    _storage.ensureUnique()
    return _storage.update {
      $0.uncheckedRemoveFirst()
    }
  }
  @inlinable public mutating func prepend(_ newElement: Element) {
    _storage.ensureUnique(minimumCapacity: count + 1)
    return _storage.update {
      $0.uncheckedPrepend(newElement)
    }
  }
  @inlinable public mutating func prepend<C>(contentsOf newElements: C) where Element == C.Element, C : Swift.Collection {
    let done: Void? = newElements._withContiguousStorageIfAvailable_SR14663 { source in
      _storage.ensureUnique(minimumCapacity: count + source.count)
      _storage.update { $0.uncheckedPrepend(contentsOf: source) }
    }
    guard done == nil else { return }

    let c = newElements.count
    guard c > 0 else { return }
    _storage.ensureUnique(minimumCapacity: count + c)
    _storage.update { target in
      let gaps = target.availableSegments().suffix(c)
      gaps.initialize(from: newElements)
      target.count += c
      target.startSlot = target.slot(target.startSlot, offsetBy: -c)
    }
  }
  @inlinable public mutating func prepend<S>(contentsOf newElements: S) where Element == S.Element, S : Swift.Sequence {
    let done: Void? = newElements._withContiguousStorageIfAvailable_SR14663 { source in
      _storage.ensureUnique(minimumCapacity: count + source.count)
      _storage.update { $0.uncheckedPrepend(contentsOf: source) }
    }
    guard done == nil else { return }

    let originalCount = self.count
    self.append(contentsOf: newElements)
    let newCount = self.count
    let c = newCount - originalCount
    _storage.update { target in
      target.startSlot = target.slot(forOffset: originalCount)
      target.count = target.capacity
      target.closeGap(offsets: c ..< c + (target.capacity - newCount))
      assert(target.count == newCount)
    }
  }
}
extension DequeModule.Deque : Swift.Hashable where Element : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(count) // discriminator
    for element in self {
      hasher.combine(element)
    }
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension DequeModule.Deque {
  @usableFromInline
  @frozen internal struct _Storage {
    @usableFromInline
    internal typealias _Buffer = Swift.ManagedBufferPointer<DequeModule._DequeBufferHeader, Element>
    @usableFromInline
    internal var _buffer: DequeModule.Deque<Element>._Storage._Buffer
    @inlinable @inline(__always) internal init(_buffer: DequeModule.Deque<Element>._Storage._Buffer) {
      self._buffer = _buffer
    }
  }
}
extension DequeModule.Deque._Storage : Swift.CustomStringConvertible {
  @usableFromInline
  internal var description: Swift.String {
    get
  }
}
extension DequeModule.Deque._Storage {
  @inlinable internal init() {
    self.init(_buffer: _Buffer(unsafeBufferObject: _emptyDequeStorage))
  }
  @inlinable internal init(_ object: DequeModule._DequeBuffer<Element>) {
    self.init(_buffer: _Buffer(unsafeBufferObject: object))
  }
  @inlinable internal init(minimumCapacity: Swift.Int) {
    let object = _DequeBuffer<Element>.create(
      minimumCapacity: minimumCapacity,
      makingHeaderWith: {
        let capacity = $0.capacity
        return _DequeBufferHeader(capacity: capacity, count: 0, startSlot: .zero)
      })
    self.init(_buffer: _Buffer(unsafeBufferObject: object))
  }
}
extension DequeModule.Deque._Storage {
  @inlinable @inline(__always) internal func _checkInvariants() {}
}
extension DequeModule.Deque._Storage {
  @inlinable @inline(__always) internal var identity: Swift.AnyObject {
    get { _buffer.buffer }
  }
  @inlinable @inline(__always) internal var capacity: Swift.Int {
    get {
    _buffer.withUnsafeMutablePointerToHeader { $0.pointee.capacity }
  }
  }
  @inlinable @inline(__always) internal var count: Swift.Int {
    get {
    _buffer.withUnsafeMutablePointerToHeader { $0.pointee.count }
  }
  }
  @inlinable @inline(__always) internal var startSlot: DequeModule._DequeSlot {
    get {
    _buffer.withUnsafeMutablePointerToHeader { $0.pointee.startSlot
    }
  }
  }
}
extension DequeModule.Deque._Storage {
  @usableFromInline
  internal typealias Index = Swift.Int
  @usableFromInline
  internal typealias _UnsafeHandle = DequeModule.Deque<Element>._UnsafeHandle
  @inlinable @inline(__always) internal func read<R>(_ body: (DequeModule.Deque<Element>._Storage._UnsafeHandle) throws -> R) rethrows -> R {
    try _buffer.withUnsafeMutablePointers { header, elements in
      let handle = _UnsafeHandle(header: header,
                                 elements: elements,
                                 isMutable: false)
      return try body(handle)
    }
  }
  @inlinable @inline(__always) internal func update<R>(_ body: (DequeModule.Deque<Element>._Storage._UnsafeHandle) throws -> R) rethrows -> R {
    try _buffer.withUnsafeMutablePointers { header, elements in
      let handle = _UnsafeHandle(header: header,
                                 elements: elements,
                                 isMutable: true)
      return try body(handle)
    }
  }
}
extension DequeModule.Deque._Storage {
  @inlinable @inline(__always) internal mutating func isUnique() -> Swift.Bool {
    _buffer.isUniqueReference()
  }
  @inlinable @inline(__always) internal mutating func ensureUnique() {
    if isUnique() { return }
    self._makeUniqueCopy()
  }
  @inlinable @inline(never) internal mutating func _makeUniqueCopy() {
    self = self.read { $0.copyElements() }
  }
  @inlinable @inline(__always) internal static var growthFactor: Swift.Double {
    get { 1.5 }
  }
  @usableFromInline
  internal func _growCapacity(to minimumCapacity: Swift.Int, linearly: Swift.Bool) -> Swift.Int
  @inlinable @inline(__always) internal mutating func ensureUnique(minimumCapacity: Swift.Int, linearGrowth: Swift.Bool = false) {
    let unique = isUnique()
    if _slowPath(capacity < minimumCapacity || !unique) {
      _ensureUnique(minimumCapacity: minimumCapacity, linearGrowth: linearGrowth)
    }
  }
  @inlinable internal mutating func _ensureUnique(minimumCapacity: Swift.Int, linearGrowth: Swift.Bool) {
    if capacity >= minimumCapacity {
      assert(!self.isUnique())
      self = self.read { $0.copyElements() }
    } else if isUnique() {
      let minimumCapacity = _growCapacity(to: minimumCapacity, linearly: linearGrowth)
      self = self.update { source in
        source.moveElements(minimumCapacity: minimumCapacity)
      }
    } else {
      let minimumCapacity = _growCapacity(to: minimumCapacity, linearly: linearGrowth)
      self = self.read { source in
        source.copyElements(minimumCapacity: minimumCapacity)
      }
    }
  }
}
extension DequeModule.Deque {
  @usableFromInline
  @frozen internal struct _UnsafeHandle {
    @usableFromInline
    internal let _header: Swift.UnsafeMutablePointer<DequeModule._DequeBufferHeader>
    @usableFromInline
    internal let _elements: Swift.UnsafeMutablePointer<Element>
    @inlinable @inline(__always) internal init(header: Swift.UnsafeMutablePointer<DequeModule._DequeBufferHeader>, elements: Swift.UnsafeMutablePointer<Element>, isMutable: Swift.Bool) {
      self._header = header
      self._elements = elements
    }
  }
}
extension DequeModule.Deque._UnsafeHandle {
  @inlinable @inline(__always) internal func assertMutable() {
  }
}
extension DequeModule.Deque._UnsafeHandle {
  @usableFromInline
  internal typealias Slot = DequeModule._DequeSlot
  @inlinable @inline(__always) internal var header: DequeModule._DequeBufferHeader {
    get {
    _header.pointee
  }
  }
  @inlinable @inline(__always) internal var capacity: Swift.Int {
    get {
    _header.pointee.capacity
  }
  }
  @inlinable @inline(__always) internal var count: Swift.Int {
    get { _header.pointee.count }
    nonmutating set { _header.pointee.count = newValue }
  }
  @inlinable @inline(__always) internal var startSlot: DequeModule.Deque<Element>._UnsafeHandle.Slot {
    get { _header.pointee.startSlot }
    nonmutating set { _header.pointee.startSlot = newValue }
  }
  @inlinable @inline(__always) internal func ptr(at slot: DequeModule.Deque<Element>._UnsafeHandle.Slot) -> Swift.UnsafeMutablePointer<Element> {
    assert(slot.position >= 0 && slot.position <= capacity)
    return _elements + slot.position
  }
}
extension DequeModule.Deque._UnsafeHandle {
  @inlinable @inline(__always) internal var mutableBuffer: Swift.UnsafeMutableBufferPointer<Element> {
    get {
    assertMutable()
    return .init(start: _elements, count: _header.pointee.capacity)
  }
  }
  @inlinable internal func buffer(for range: Swift.Range<DequeModule.Deque<Element>._UnsafeHandle.Slot>) -> Swift.UnsafeBufferPointer<Element> {
    assert(range.upperBound.position <= capacity)
    return .init(start: _elements + range.lowerBound.position, count: range._count)
  }
  @inlinable @inline(__always) internal func mutableBuffer(for range: Swift.Range<DequeModule.Deque<Element>._UnsafeHandle.Slot>) -> Swift.UnsafeMutableBufferPointer<Element> {
    assertMutable()
    return .init(mutating: buffer(for: range))
  }
}
extension DequeModule.Deque._UnsafeHandle {
  @inlinable @inline(__always) internal var limSlot: DequeModule.Deque<Element>._UnsafeHandle.Slot {
    get {
    Slot(at: capacity)
  }
  }
  @inlinable internal func slot(after slot: DequeModule.Deque<Element>._UnsafeHandle.Slot) -> DequeModule.Deque<Element>._UnsafeHandle.Slot {
    assert(slot.position < capacity)
    let position = slot.position + 1
    if position >= capacity {
      return Slot(at: 0)
    }
    return Slot(at: position)
  }
  @inlinable internal func slot(before slot: DequeModule.Deque<Element>._UnsafeHandle.Slot) -> DequeModule.Deque<Element>._UnsafeHandle.Slot {
    assert(slot.position < capacity)
    if slot.position == 0 { return Slot(at: capacity - 1) }
    return Slot(at: slot.position - 1)
  }
  @inlinable internal func slot(_ slot: DequeModule.Deque<Element>._UnsafeHandle.Slot, offsetBy delta: Swift.Int) -> DequeModule.Deque<Element>._UnsafeHandle.Slot {
    assert(slot.position <= capacity)
    let position = slot.position + delta
    if delta >= 0 {
      if position >= capacity { return Slot(at: position - capacity) }
    } else {
      if position < 0 { return Slot(at: position + capacity) }
    }
    return Slot(at: position)
  }
  @inlinable @inline(__always) internal var endSlot: DequeModule.Deque<Element>._UnsafeHandle.Slot {
    get {
    slot(startSlot, offsetBy: count)
  }
  }
  @inlinable internal func slot(forOffset offset: Swift.Int) -> DequeModule.Deque<Element>._UnsafeHandle.Slot {
    assert(offset >= 0)
    assert(offset <= capacity) // Not `count`!

    // Note: The use of wrapping addition/subscription is justified here by the
    // fact that `offset` is guaranteed to fall in the range `0 ..< capacity`.
    // Eliminating the overflow checks leads to a measurable speedup for
    // random-access subscript operations. (Up to 2x on some microbenchmarks.)
    let position = startSlot.position &+ offset
    guard position < capacity else { return Slot(at: position &- capacity) }
    return Slot(at: position)
  }
}
extension DequeModule.Deque._UnsafeHandle {
  @inlinable internal func segments() -> DequeModule._UnsafeWrappedBuffer<Element> {
    let wrap = capacity - startSlot.position
    if count <= wrap {
      return .init(start: ptr(at: startSlot), count: count)
    }
    return .init(first: ptr(at: startSlot), count: wrap,
                 second: ptr(at: .zero), count: count - wrap)
  }
  @inlinable internal func segments(forOffsets offsets: Swift.Range<Swift.Int>) -> DequeModule._UnsafeWrappedBuffer<Element> {
    assert(offsets.lowerBound >= 0 && offsets.upperBound <= count)
    let lower = slot(forOffset: offsets.lowerBound)
    let upper = slot(forOffset: offsets.upperBound)
    if offsets.count == 0 || lower < upper {
      return .init(start: ptr(at: lower), count: offsets.count)
    }
    return .init(first: ptr(at: lower), count: capacity - lower.position,
                 second: ptr(at: .zero), count: upper.position)
  }
  @inlinable @inline(__always) internal func mutableSegments() -> DequeModule._UnsafeMutableWrappedBuffer<Element> {
    assertMutable()
    return .init(mutating: segments())
  }
  @inlinable @inline(__always) internal func mutableSegments(forOffsets range: Swift.Range<Swift.Int>) -> DequeModule._UnsafeMutableWrappedBuffer<Element> {
    assertMutable()
    return .init(mutating: segments(forOffsets: range))
  }
}
extension DequeModule.Deque._UnsafeHandle {
  @inlinable internal func availableSegments() -> DequeModule._UnsafeMutableWrappedBuffer<Element> {
    assertMutable()
    let endSlot = self.endSlot
    guard count < capacity else { return .init(start: ptr(at: endSlot), count: 0) }
    if endSlot < startSlot { return .init(mutableBuffer(for: endSlot ..< startSlot)) }
    return .init(mutableBuffer(for: endSlot ..< limSlot),
                 mutableBuffer(for: .zero ..< startSlot))
  }
}
extension DequeModule.Deque._UnsafeHandle {
  @discardableResult
  @inlinable internal func initialize(at start: DequeModule.Deque<Element>._UnsafeHandle.Slot, from source: Swift.UnsafeBufferPointer<Element>) -> DequeModule.Deque<Element>._UnsafeHandle.Slot {
    assert(start.position + source.count <= capacity)
    guard source.count > 0 else { return start }
    ptr(at: start).initialize(from: source.baseAddress!, count: source.count)
    return Slot(at: start.position + source.count)
  }
  @discardableResult
  @inlinable @inline(__always) internal func moveInitialize(at start: DequeModule.Deque<Element>._UnsafeHandle.Slot, from source: Swift.UnsafeMutableBufferPointer<Element>) -> DequeModule.Deque<Element>._UnsafeHandle.Slot {
    assert(start.position + source.count <= capacity)
    guard source.count > 0 else { return start }
    ptr(at: start).moveInitialize(from: source.baseAddress!, count: source.count)
    return Slot(at: start.position + source.count)
  }
  @discardableResult
  @inlinable @inline(__always) public func move(from source: DequeModule.Deque<Element>._UnsafeHandle.Slot, to target: DequeModule.Deque<Element>._UnsafeHandle.Slot, count: Swift.Int) -> (source: DequeModule.Deque<Element>._UnsafeHandle.Slot, target: DequeModule.Deque<Element>._UnsafeHandle.Slot) {
    assert(count >= 0)
    assert(source.position + count <= self.capacity)
    assert(target.position + count <= self.capacity)
    guard count > 0 else { return (source, target) }
    ptr(at: target).moveInitialize(from: ptr(at: source), count: count)
    return (slot(source, offsetBy: count), slot(target, offsetBy: count))
  }
}
extension DequeModule.Deque._UnsafeHandle {
  @inlinable internal func copyElements() -> DequeModule.Deque<Element>._Storage {
    let object = _DequeBuffer<Element>.create(
      minimumCapacity: capacity,
      makingHeaderWith: { _ in header })
    let result = Deque._Storage(_buffer: ManagedBufferPointer(unsafeBufferObject: object))
    guard self.count > 0 else { return result }
    result.update { target in
      let source = self.segments()
      target.initialize(at: startSlot, from: source.first)
      if let second = source.second {
        target.initialize(at: .zero, from: second)
      }
    }
    return result
  }
  @inlinable internal func copyElements(minimumCapacity: Swift.Int) -> DequeModule.Deque<Element>._Storage {
    assert(minimumCapacity >= count)
    let object = _DequeBuffer<Element>.create(
      minimumCapacity: minimumCapacity,
      makingHeaderWith: {
        let capacity = $0.capacity
        return _DequeBufferHeader(
          capacity: capacity,
          count: count,
          startSlot: .zero)
      })
    let result = Deque._Storage(_buffer: ManagedBufferPointer(unsafeBufferObject: object))
    guard count > 0 else { return result }
    result.update { target in
      assert(target.count == count && target.startSlot.position == 0)
      let source = self.segments()
      let next = target.initialize(at: .zero, from: source.first)
      if let second = source.second {
        target.initialize(at: next, from: second)
      }
    }
    return result
  }
  @inlinable internal func moveElements(minimumCapacity: Swift.Int) -> DequeModule.Deque<Element>._Storage {
    assertMutable()
    let count = self.count
    assert(minimumCapacity >= count)
    let object = _DequeBuffer<Element>.create(
      minimumCapacity: minimumCapacity,
      makingHeaderWith: {
        let capacity = $0.capacity
        return _DequeBufferHeader(
          capacity: capacity,
          count: count,
          startSlot: .zero)
      })
    let result = Deque._Storage(_buffer: ManagedBufferPointer(unsafeBufferObject: object))
    guard count > 0 else { return result }
    result.update { target in
      let source = self.mutableSegments()
      let next = target.moveInitialize(at: .zero, from: source.first)
      if let second = source.second {
        target.moveInitialize(at: next, from: second)
      }
    }
    self.count = 0
    return result
  }
}
extension DequeModule.Deque._UnsafeHandle {
  @inlinable internal func withUnsafeSegment<R>(startingAt start: Swift.Int, maximumCount: Swift.Int?, _ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> (end: Swift.Int, result: R) {
    assert(start <= count)
    guard start < count else {
      return try (count, body(UnsafeBufferPointer(start: nil, count: 0)))
    }
    let endSlot = self.endSlot

    let segmentStart = self.slot(forOffset: start)
    let segmentEnd = segmentStart < endSlot ? endSlot : limSlot
    let count = Swift.min(maximumCount ?? Int.max, segmentEnd.position - segmentStart.position)
    let result = try body(UnsafeBufferPointer(start: ptr(at: segmentStart), count: count))
    return (start + count, result)
  }
}
extension DequeModule.Deque._UnsafeHandle {
  @inlinable internal func uncheckedReplaceInPlace<C>(inOffsets range: Swift.Range<Swift.Int>, with newElements: C) where Element == C.Element, C : Swift.Collection {
    assertMutable()
    assert(range.upperBound <= count)
    assert(newElements.count == range.count)
    guard !range.isEmpty else { return }
    let target = mutableSegments(forOffsets: range)
    target.assign(from: newElements)
  }
}
extension DequeModule.Deque._UnsafeHandle {
  @inlinable internal func uncheckedAppend(_ element: Element) {
    assertMutable()
    assert(count < capacity)
    ptr(at: endSlot).initialize(to: element)
    count += 1
  }
  @inlinable internal func uncheckedAppend(contentsOf source: Swift.UnsafeBufferPointer<Element>) {
    assertMutable()
    assert(count + source.count <= capacity)
    guard source.count > 0 else { return }
    let c = self.count
    count += source.count
    let gap = mutableSegments(forOffsets: c ..< count)
    gap.initialize(from: source)
  }
}
extension DequeModule.Deque._UnsafeHandle {
  @inlinable internal func uncheckedPrepend(_ element: Element) {
    assertMutable()
    assert(count < capacity)
    let slot = self.slot(before: startSlot)
    ptr(at: slot).initialize(to: element)
    startSlot = slot
    count += 1
  }
  @inlinable internal func uncheckedPrepend(contentsOf source: Swift.UnsafeBufferPointer<Element>) {
    assertMutable()
    assert(count + source.count <= capacity)
    guard source.count > 0 else { return }
    let oldStart = startSlot
    let newStart = self.slot(startSlot, offsetBy: -source.count)
    startSlot = newStart
    count += source.count

    let gap = mutableWrappedBuffer(between: newStart, and: oldStart)
    gap.initialize(from: source)
  }
}
extension DequeModule.Deque._UnsafeHandle {
  @inlinable internal func uncheckedInsert<C>(contentsOf newElements: __owned C, count newCount: Swift.Int, atOffset offset: Swift.Int) where Element == C.Element, C : Swift.Collection {
    assertMutable()
    assert(offset <= count)
    assert(newElements.count == newCount)
    guard newCount > 0 else { return }
    let gap = openGap(ofSize: newCount, atOffset: offset)
    gap.initialize(from: newElements)
  }
  @inlinable internal func mutableWrappedBuffer(between start: DequeModule.Deque<Element>._UnsafeHandle.Slot, and end: DequeModule.Deque<Element>._UnsafeHandle.Slot) -> DequeModule._UnsafeMutableWrappedBuffer<Element> {
    assert(start.position <= capacity)
    assert(end.position <= capacity)
    if start < end {
      return .init(start: ptr(at: start), count: end.position - start.position)
    }
    return .init(
      first: ptr(at: start), count: capacity - start.position,
      second: ptr(at: .zero), count: end.position)
  }
  @inlinable internal func openGap(ofSize gapSize: Swift.Int, atOffset offset: Swift.Int) -> DequeModule._UnsafeMutableWrappedBuffer<Element> {
    assertMutable()
    assert(offset >= 0 && offset <= self.count)
    assert(self.count + gapSize <= capacity)
    assert(gapSize > 0)

    let headCount = offset
    let tailCount = count - offset
    if tailCount <= headCount {
      // Open the gap by sliding elements to the right.

      let originalEnd = self.slot(startSlot, offsetBy: count)
      let newEnd = self.slot(startSlot, offsetBy: count + gapSize)
      let gapStart = self.slot(forOffset: offset)
      let gapEnd = self.slot(gapStart, offsetBy: gapSize)

      let sourceIsContiguous = gapStart <= originalEnd.orIfZero(capacity)
      let targetIsContiguous = gapEnd <= newEnd.orIfZero(capacity)

      if sourceIsContiguous && targetIsContiguous {
        // No need to deal with wrapping; we just need to slide
        // elements after the gap.

        // Illustrated steps: (underscores mark eventual gap position)
        //
        //   0) ....ABCDE̲F̲G̲H.....      EFG̲H̲.̲........ABCD      .̲.......ABCDEFGH̲.̲
        //   1) ....ABCD.̲.̲.̲EFGH..      EF.̲.̲.̲GH......ABCD      .̲H......ABCDEFG.̲.̲
        move(from: gapStart, to: gapEnd, count: tailCount)
      } else if targetIsContiguous {
        // The gap itself will be wrapped.

        // Illustrated steps: (underscores mark eventual gap position)
        //
        //   0) E̲FGH.........ABC̲D̲
        //   1) .̲..EFGH......ABC̲D̲
        //   2) .̲CDEFGH......AB.̲.̲
        assert(startSlot > originalEnd.orIfZero(capacity))
        move(from: .zero, to: Slot.zero.advanced(by: gapSize), count: originalEnd.position)
        move(from: gapStart, to: gapEnd, count: capacity - gapStart.position)
      } else if sourceIsContiguous {
        // Opening the gap pushes subsequent elements across the wrap.

        // Illustrated steps: (underscores mark eventual gap position)
        //
        //   0) ........ABC̲D̲E̲FGH.
        //   1) GH......ABC̲D̲E̲F...
        //   2) GH......AB.̲.̲.̲CDEF
        move(from: limSlot.advanced(by: -gapSize), to: .zero, count: newEnd.position)
        move(from: gapStart, to: gapEnd, count: tailCount - newEnd.position)
      } else {
        // The rest of the items are wrapped, and will remain so.

        // Illustrated steps: (underscores mark eventual gap position)
        //
        //   0) GH.........AB̲C̲D̲EF
        //   1) ...GH......AB̲C̲D̲EF
        //   2) DEFGH......AB̲C̲.̲..
        //   3) DEFGH......A.̲.̲.̲BC
        move(from: .zero, to: Slot.zero.advanced(by: gapSize), count: originalEnd.position)
        move(from: limSlot.advanced(by: -gapSize), to: .zero, count: gapSize)
        move(from: gapStart, to: gapEnd, count: tailCount - gapSize - originalEnd.position)
      }
      count += gapSize
      return mutableWrappedBuffer(between: gapStart, and: gapEnd.orIfZero(capacity))
    }

    // Open the gap by sliding elements to the left.

    let originalStart = self.startSlot
    let newStart = self.slot(originalStart, offsetBy: -gapSize)
    let gapEnd = self.slot(forOffset: offset)
    let gapStart = self.slot(gapEnd, offsetBy: -gapSize)

    let sourceIsContiguous = originalStart <= gapEnd.orIfZero(capacity)
    let targetIsContiguous = newStart <= gapStart.orIfZero(capacity)

    if sourceIsContiguous && targetIsContiguous {
      // No need to deal with any wrapping.

      // Illustrated steps: (underscores mark eventual gap position)
      //
      //   0) ....A̲B̲C̲DEFGH...      GH.........̲A̲B̲CDEF      .̲A̲B̲CDEFGH.......̲.̲
      //   1) .ABC.̲.̲.̲DEFGH...      GH......AB.̲.̲.̲CDEF      .̲.̲.̲CDEFGH....AB.̲.̲
      move(from: originalStart, to: newStart, count: headCount)
    } else if targetIsContiguous {
      // The gap itself will be wrapped.

      // Illustrated steps: (underscores mark eventual gap position)
      //
      //   0) C̲D̲EFGH.........A̲B̲
      //   1) C̲D̲EFGH.....AB...̲.̲
      //   2) .̲.̲EFGH.....ABCD.̲.̲
      assert(originalStart >= newStart)
      move(from: originalStart, to: newStart, count: capacity - originalStart.position)
      move(from: .zero, to: limSlot.advanced(by: -gapSize), count: gapEnd.position)
    } else if sourceIsContiguous {
      // Opening the gap pushes preceding elements across the wrap.

      // Illustrated steps: (underscores mark eventual gap position)
      //
      //   0) .AB̲C̲D̲EFGH.........
      //   1) ...̲C̲D̲EFGH.......AB
      //   2) CD.̲.̲.̲EFGH.......AB
      move(from: originalStart, to: newStart, count: capacity - newStart.position)
      move(from: Slot.zero.advanced(by: gapSize), to: .zero, count: gapStart.position)
    } else {
      // The preceding of the items are wrapped, and will remain so.

      // Illustrated steps: (underscores mark eventual gap position)
      //   0) CD̲E̲F̲GHIJKL.........AB
      //   1) CD̲E̲F̲GHIJKL......AB...
      //   2) ..̲.̲F̲GHIJKL......ABCDE
      //   3) F.̲.̲.̲GHIJKL......ABCDE
      move(from: originalStart, to: newStart, count: capacity - originalStart.position)
      move(from: .zero, to: limSlot.advanced(by: -gapSize), count: gapSize)
      move(from: Slot.zero.advanced(by: gapSize), to: .zero, count: gapStart.position)
    }
    startSlot = newStart
    count += gapSize
    return mutableWrappedBuffer(between: gapStart, and: gapEnd.orIfZero(capacity))
  }
}
extension DequeModule.Deque._UnsafeHandle {
  @inlinable internal func uncheckedRemoveFirst() -> Element {
    assertMutable()
    assert(count > 0)
    let result = ptr(at: startSlot).move()
    startSlot = slot(after: startSlot)
    count -= 1
    return result
  }
  @inlinable internal func uncheckedRemoveLast() -> Element {
    assertMutable()
    assert(count > 0)
    let slot = self.slot(forOffset: count - 1)
    let result = ptr(at: slot).move()
    count -= 1
    return result
  }
  @inlinable internal func uncheckedRemoveFirst(_ n: Swift.Int) {
    assertMutable()
    assert(count >= n)
    guard n > 0 else { return }
    let target = mutableSegments(forOffsets: 0 ..< n)
    target.deinitialize()
    startSlot = slot(startSlot, offsetBy: n)
    count -= n
  }
  @inlinable internal func uncheckedRemoveLast(_ n: Swift.Int) {
    assertMutable()
    assert(count >= n)
    guard n > 0 else { return }
    let target = mutableSegments(forOffsets: count - n ..< count)
    target.deinitialize()
    count -= n
  }
  @inlinable internal func uncheckedRemoveAll() {
    assertMutable()
    guard count > 0 else { return }
    let target = mutableSegments()
    target.deinitialize()
    count = 0
    startSlot = .zero
  }
  @inlinable internal func uncheckedRemove(offsets bounds: Swift.Range<Swift.Int>) {
    assertMutable()
    assert(bounds.lowerBound >= 0 && bounds.upperBound <= self.count)

    // Deinitialize elements in `bounds`.
    mutableSegments(forOffsets: bounds).deinitialize()
    closeGap(offsets: bounds)
  }
  @inlinable internal func closeGap(offsets bounds: Swift.Range<Swift.Int>) {
    assertMutable()
    assert(bounds.lowerBound >= 0 && bounds.upperBound <= self.count)
    let gapSize = bounds.count
    guard gapSize > 0 else { return }

    let gapStart = self.slot(forOffset: bounds.lowerBound)
    let gapEnd = self.slot(forOffset: bounds.upperBound)

    let headCount = bounds.lowerBound
    let tailCount = count - bounds.upperBound

    if headCount >= tailCount {
      // Close the gap by sliding elements to the left.
      let originalEnd = endSlot
      let newEnd = self.slot(forOffset: count - gapSize)

      let sourceIsContiguous = gapEnd < originalEnd.orIfZero(capacity)
      let targetIsContiguous = gapStart <= newEnd.orIfZero(capacity)
      if tailCount == 0 {
        // No need to move any elements.
      } else if sourceIsContiguous && targetIsContiguous {
        // No need to deal with wrapping.

        //   0) ....ABCD.̲.̲.̲EFGH..   EF.̲.̲.̲GH........ABCD   .̲.̲.̲E..........ABCD.̲.̲   .̲.̲.̲EF........ABCD .̲.̲.̲DE.......ABC
        //   1) ....ABCDE̲F̲G̲H.....   EFG̲H̲.̲..........ABCD   .̲.̲.̲...........ABCDE̲.̲   E̲F̲.̲..........ABCD D̲E̲.̲.........ABC
        move(from: gapEnd, to: gapStart, count: tailCount)
      } else if sourceIsContiguous {
        // The gap lies across the wrap from the subsequent elements.

        //   0) .̲.̲.̲EFGH.......ABCD.̲.̲      EFGH.......ABCD.̲.̲.̲
        //   1) .̲.̲.̲..GH.......ABCDE̲F̲      ..GH.......ABCDE̲F̲G̲
        //   2) G̲H̲.̲...........ABCDE̲F̲      GH.........ABCDE̲F̲G̲
        let c = capacity - gapStart.position
        assert(tailCount > c)
        let next = move(from: gapEnd, to: gapStart, count: c)
        move(from: next.source, to: .zero, count: tailCount - c)
      } else if targetIsContiguous {
        // We need to move elements across a wrap, but the wrap will
        // disappear when we're done.

        //   0) HI....ABCDE.̲.̲.̲FG
        //   1) HI....ABCDEF̲G̲.̲..
        //   2) ......ABCDEF̲G̲H̲I.
        let next = move(from: gapEnd, to: gapStart, count: capacity - gapEnd.position)
        move(from: .zero, to: next.target, count: originalEnd.position)
      } else {
        // We need to move elements across a wrap that won't go away.

        //   0) HIJKL....ABCDE.̲.̲.̲FG
        //   1) HIJKL....ABCDEF̲G̲.̲..
        //   2) ...KL....ABCDEF̲G̲H̲IJ
        //   3) KL.......ABCDEF̲G̲H̲IJ
        var next = move(from: gapEnd, to: gapStart, count: capacity - gapEnd.position)
        next = move(from: .zero, to: next.target, count: gapSize)
        move(from: next.source, to: .zero, count: newEnd.position)
      }
      count -= gapSize
    } else {
      // Close the gap by sliding elements to the right.
      let originalStart = startSlot
      let newStart = slot(startSlot, offsetBy: gapSize)

      let sourceIsContiguous = originalStart < gapStart.orIfZero(capacity)
      let targetIsContiguous = newStart <= gapEnd.orIfZero(capacity)

      if headCount == 0 {
        // No need to move any elements.
      } else if sourceIsContiguous && targetIsContiguous {
        // No need to deal with wrapping.

        //   0) ....ABCD.̲.̲.̲EFGH.....   EFGH........AB.̲.̲.̲CD   .̲.̲.̲CDEFGH.......AB.̲.̲   DEFGH.......ABC.̲.̲
        //   1) .......AB̲C̲D̲EFGH.....   EFGH...........̲A̲B̲CD   .̲A̲B̲CDEFGH..........̲.̲   DEFGH.........AB̲C̲     ABCDEFGH........̲.̲.̲
        move(from: originalStart, to: newStart, count: headCount)
      } else if sourceIsContiguous {
        // The gap lies across the wrap from the preceding elements.

        //   0) .̲.̲DEFGH.......ABC.̲.̲     .̲.̲.̲EFGH.......ABCD
        //   1) B̲C̲DEFGH.......A...̲.̲     B̲C̲D̲DEFGH......A...
        //   2) B̲C̲DEFGH...........̲A̲     B̲C̲D̲DEFGH.........A
        move(from: limSlot.advanced(by: -gapSize), to: .zero, count: gapEnd.position)
        move(from: startSlot, to: newStart, count: headCount - gapEnd.position)
      } else if targetIsContiguous {
        // We need to move elements across a wrap, but the wrap will
        // disappear when we're done.

        //   0) CD.̲.̲.̲EFGHI.....AB
        //   1) ...̲C̲D̲EFGHI.....AB
        //   1) .AB̲C̲D̲EFGHI.......
        move(from: .zero, to: gapEnd.advanced(by: -gapStart.position), count: gapStart.position)
        move(from: startSlot, to: newStart, count: headCount - gapStart.position)
      } else {
        // We need to move elements across a wrap that won't go away.
        //   0) FG.̲.̲.̲HIJKLMNO....ABCDE
        //   1) ...̲F̲G̲HIJKLMNO....ABCDE
        //   2) CDE̲F̲G̲HIJKLMNO....AB...
        //   3) CDE̲F̲G̲HIJKLMNO.......AB
        move(from: .zero, to: Slot.zero.advanced(by: gapSize), count: gapStart.position)
        move(from: limSlot.advanced(by: -gapSize), to: .zero, count: gapSize)
        move(from: startSlot, to: newStart, count: headCount - gapEnd.position)
      }
      startSlot = newStart
      count -= gapSize
    }
  }
}
@frozen public struct Deque<Element> {
  @usableFromInline
  internal typealias _Slot = DequeModule._DequeSlot
  @usableFromInline
  internal var _storage: DequeModule.Deque<Element>._Storage
  @inlinable internal init(_storage: DequeModule.Deque<Element>._Storage) {
    self._storage = _storage
  }
  @inlinable public init(minimumCapacity: Swift.Int) {
    self._storage = _Storage(minimumCapacity: minimumCapacity)
  }
}
extension Swift.Collection {
  @inlinable @inline(__always) internal func _rebased<Element>() -> Swift.UnsafeBufferPointer<Element> where Self == Swift.Slice<Swift.UnsafeBufferPointer<Element>> {
    .init(rebasing: self)
  }
}
extension Swift.Collection {
  @inlinable @inline(__always) internal func _rebased<Element>() -> Swift.UnsafeMutableBufferPointer<Element> where Self == Swift.Slice<Swift.UnsafeMutableBufferPointer<Element>> {
    .init(rebasing: self)
  }
}
extension Swift.UnsafeMutableBufferPointer {
  @inlinable @inline(__always) internal func _initialize(from source: Swift.UnsafeBufferPointer<Element>) {
    assert(source.count == count)
    guard source.count > 0 else { return }
    baseAddress!.initialize(from: source.baseAddress!, count: source.count)
  }
  @inlinable @inline(__always) internal func _initialize<C>(from elements: C) where Element == C.Element, C : Swift.Collection {
    assert(elements.count == count)
    var (it, copied) = elements._copyContents(initializing: self)
    precondition(copied == count)
    precondition(it.next() == nil)
  }
  @inlinable @inline(__always) internal func _deinitializeAll() {
    guard count > 0 else { return }
    baseAddress!.deinitialize(count: count)
  }
  @inlinable internal func _assign<C>(from replacement: C) where Element == C.Element, C : Swift.Collection {
    guard self.count > 0 else { return }
    self[0 ..< count]._rebased()._deinitializeAll()
    _initialize(from: replacement)
  }
}
@_inheritsConvenienceInitializers @usableFromInline
@_fixed_layout internal class _DequeBuffer<Element> : Swift.ManagedBuffer<DequeModule._DequeBufferHeader, Element> {
  @objc @inlinable deinit {
    self.withUnsafeMutablePointers { header, elements in
      header.pointee._checkInvariants()

      let capacity = header.pointee.capacity
      let count = header.pointee.count
      let startSlot = header.pointee.startSlot

      if startSlot.position + count <= capacity {
        (elements + startSlot.position).deinitialize(count: count)
      } else {
        let firstRegion = capacity - startSlot.position
        (elements + startSlot.position).deinitialize(count: firstRegion)
        elements.deinitialize(count: count - firstRegion)
      }
    }
  }
}
extension DequeModule._DequeBuffer : Swift.CustomStringConvertible {
  @usableFromInline
  internal var description: Swift.String {
    get
  }
}
@usableFromInline
internal let _emptyDequeStorage: Swift.ManagedBuffer<DequeModule._DequeBufferHeader, Swift.Void>
@usableFromInline
internal struct _DequeBufferHeader {
  @usableFromInline
  internal var capacity: Swift.Int
  @usableFromInline
  internal var count: Swift.Int
  @usableFromInline
  internal var startSlot: DequeModule._DequeSlot
  @usableFromInline
  internal init(capacity: Swift.Int, count: Swift.Int, startSlot: DequeModule._DequeSlot)
  @inlinable @inline(__always) internal func _checkInvariants() {}
}
extension DequeModule._DequeBufferHeader : Swift.CustomStringConvertible {
  @usableFromInline
  internal var description: Swift.String {
    get
  }
}
@usableFromInline
@frozen internal struct _DequeSlot {
  @usableFromInline
  internal var position: Swift.Int
  @inlinable @inline(__always) internal init(at position: Swift.Int) {
    assert(position >= 0)
    self.position = position
  }
}
extension DequeModule._DequeSlot {
  @inlinable @inline(__always) internal static var zero: DequeModule._DequeSlot {
    get { Self(at: 0) }
  }
  @inlinable @inline(__always) internal func advanced(by delta: Swift.Int) -> DequeModule._DequeSlot {
    Self(at: position &+ delta)
  }
  @inlinable @inline(__always) internal func orIfZero(_ value: Swift.Int) -> DequeModule._DequeSlot {
    guard position > 0 else { return Self(at: value) }
    return self
  }
}
extension DequeModule._DequeSlot : Swift.CustomStringConvertible {
  @usableFromInline
  internal var description: Swift.String {
    get
  }
}
extension DequeModule._DequeSlot : Swift.Equatable {
  @inlinable @inline(__always) internal static func == (left: DequeModule._DequeSlot, right: DequeModule._DequeSlot) -> Swift.Bool {
    left.position == right.position
  }
}
extension DequeModule._DequeSlot : Swift.Comparable {
  @inlinable @inline(__always) internal static func < (left: DequeModule._DequeSlot, right: DequeModule._DequeSlot) -> Swift.Bool {
    left.position < right.position
  }
}
extension Swift.Range where Bound == DequeModule._DequeSlot {
  @inlinable @inline(__always) internal var _count: Swift.Int {
    get { upperBound.position - lowerBound.position }
  }
}
@usableFromInline
@frozen internal struct _UnsafeWrappedBuffer<Element> {
  @usableFromInline
  internal let first: Swift.UnsafeBufferPointer<Element>
  @usableFromInline
  internal let second: Swift.UnsafeBufferPointer<Element>?
  @inlinable @inline(__always) internal init(_ first: Swift.UnsafeBufferPointer<Element>, _ second: Swift.UnsafeBufferPointer<Element>? = nil) {
    self.first = first
    self.second = second
    assert(first.count > 0 || second == nil)
  }
  @inlinable internal init(start: Swift.UnsafePointer<Element>, count: Swift.Int) {
    self.init(UnsafeBufferPointer(start: start, count: count))
  }
  @inlinable internal init(first start1: Swift.UnsafePointer<Element>, count count1: Swift.Int, second start2: Swift.UnsafePointer<Element>, count count2: Swift.Int) {
    self.init(UnsafeBufferPointer(start: start1, count: count1),
              UnsafeBufferPointer(start: start2, count: count2))
  }
  @inlinable internal var count: Swift.Int {
    get { first.count + (second?.count ?? 0) }
  }
}
@usableFromInline
@frozen internal struct _UnsafeMutableWrappedBuffer<Element> {
  @usableFromInline
  internal let first: Swift.UnsafeMutableBufferPointer<Element>
  @usableFromInline
  internal let second: Swift.UnsafeMutableBufferPointer<Element>?
  @inlinable @inline(__always) internal init(_ first: Swift.UnsafeMutableBufferPointer<Element>, _ second: Swift.UnsafeMutableBufferPointer<Element>? = nil) {
    self.first = first
    self.second = second?.count == 0 ? nil : second
    assert(first.count > 0 || second == nil)
  }
  @inlinable @inline(__always) internal init(start: Swift.UnsafeMutablePointer<Element>, count: Swift.Int) {
    self.init(UnsafeMutableBufferPointer(start: start, count: count))
  }
  @inlinable @inline(__always) internal init(first start1: Swift.UnsafeMutablePointer<Element>, count count1: Swift.Int, second start2: Swift.UnsafeMutablePointer<Element>, count count2: Swift.Int) {
    self.init(UnsafeMutableBufferPointer(start: start1, count: count1),
              UnsafeMutableBufferPointer(start: start2, count: count2))
  }
  @inlinable @inline(__always) internal init(mutating buffer: DequeModule._UnsafeWrappedBuffer<Element>) {
    self.init(.init(mutating: buffer.first),
              buffer.second.map { .init(mutating: $0) })
  }
}
extension DequeModule._UnsafeMutableWrappedBuffer {
  @inlinable @inline(__always) internal var count: Swift.Int {
    get { first.count + (second?.count ?? 0) }
  }
  @inlinable internal func prefix(_ n: Swift.Int) -> DequeModule._UnsafeMutableWrappedBuffer<Element> {
    assert(n >= 0)
    if n >= self.count {
      return self
    }
    if n <= first.count {
      return Self(first.prefix(n)._rebased())
    }
    return Self(first, second!.prefix(n - first.count)._rebased())
  }
  @inlinable internal func suffix(_ n: Swift.Int) -> DequeModule._UnsafeMutableWrappedBuffer<Element> {
    assert(n >= 0)
    if n >= self.count {
      return self
    }
    guard let second = second else {
      return Self(first.suffix(n)._rebased())
    }
    if n <= second.count {
      return Self(second.suffix(n)._rebased())
    }
    return Self(first.suffix(n - second.count)._rebased(), second)
  }
}
extension DequeModule._UnsafeMutableWrappedBuffer {
  @inlinable internal func deinitialize() {
    first._deinitializeAll()
    second?._deinitializeAll()
  }
  @discardableResult
  @inlinable internal func initialize<I>(fromPrefixOf iterator: inout I) -> Swift.Int where Element == I.Element, I : Swift.IteratorProtocol {
    var copied = 0
    var gap = first
    var wrapped = false
    while true {
      if copied == gap.count {
        guard !wrapped, let second = second, second.count > 0 else { break }
        gap = second
        copied = 0
        wrapped = true
      }
      guard let next = iterator.next() else { break }
      (gap.baseAddress! + copied).initialize(to: next)
      copied += 1
    }
    return wrapped ? first.count + copied : copied
  }
  @inlinable internal func initialize<S>(fromSequencePrefix elements: __owned S) -> (iterator: S.Iterator, count: Swift.Int) where Element == S.Element, S : Swift.Sequence {
    guard second == nil || first.count >= elements.underestimatedCount else {
      var it = elements.makeIterator()
      let copied = initialize(fromPrefixOf: &it)
      return (it, copied)
    }
    // Note: Array._copyContents traps when not given enough space, so we
    // need to check if we have enough contiguous space available above.
    //
    // FIXME: Add suppport for segmented (a.k.a. piecewise contiguous)
    // collections to the stdlib.
    var (it, copied) = elements._copyContents(initializing: first)
    if copied == first.count, let second = second {
      var i = 0
      while i < second.count {
        guard let next = it.next() else { break }
        (second.baseAddress! + i).initialize(to: next)
        i += 1
      }
      copied += i
    }
    return (it, copied)
  }
  @inlinable internal func initialize<C>(from elements: __owned C) where Element == C.Element, C : Swift.Collection {
    assert(self.count == elements.count)
    if let second = second {
      let wrap = elements.index(elements.startIndex, offsetBy: first.count)
      first._initialize(from: elements[..<wrap])
      second._initialize(from: elements[wrap...])
    } else {
      first._initialize(from: elements)
    }
  }
  @inlinable internal func assign<C>(from elements: C) where Element == C.Element, C : Swift.Collection {
    assert(elements.count == self.count)
    deinitialize()
    initialize(from: elements)
  }
}
extension DequeModule.Deque : Swift.Sendable {}
extension DequeModule.Deque.Iterator : Swift.Sendable {}
extension DequeModule.Deque._Storage : Swift.Sendable {}
extension DequeModule.Deque._UnsafeHandle : Swift.Sendable {}
extension DequeModule._DequeSlot : Swift.Sendable {}
extension DequeModule._UnsafeWrappedBuffer : Swift.Sendable {}
extension DequeModule._UnsafeMutableWrappedBuffer : Swift.Sendable {}
